# Kitsune Architecture v0.0.3

## Goal
Add a status lookup flow so clients can submit async work and query completion by `event_id`.

---

## API Additions

### 1) Execute API
- Endpoint: **POST** `/api/v1/execute`
- Behavior:
	- Accept request payload for command execution.
	- Generate `event_id` on Kitsune side.
	- Resolve idempotency key as:
		- Use client-provided `metadata.idempotency_key` if present.
		- Otherwise fallback to generated `event_id`.
	- Produce events to Kafka (`db-events`, and `app-logs` when log payload exists).
	- Return `202 Accepted` with `event_id`.

### 2) Status API
- Endpoint: **GET** `/api/status/:eventID`
- Behavior:
	- Read current processing status from `result` topic materialization/internal status store.
	- Return terminal/non-terminal state for the provided `event_id`.

---

## ID Contract (Final)

### `event_id`
- **Not accepted from client input**.
- **Always generated by Kitsune API** at request acceptance.
- **Required** in internal events (`db-events`, `app-logs`, `result`) and status records.

### `idempotency_key`
- Optional in request input.
- If provided by client, use as-is after validation.
- If omitted/empty, API sets it to `event_id`.
- Must be **always present** in emitted command event and idempotency tracking.

---

## DTO / Event Struct Guidelines

### Request DTOs
- Keep request and internal event structs separate.
- `ExecuteRequest` should not contain `event_id`.
- `metadata.idempotency_key` may be optional in request DTO (`omitempty` allowed).

### Internal / Kafka Events
- `CommandEvent.event_id` must be required (no `omitempty`).
- `CommandEvent.metadata.idempotency_key` must be set before publish.
- `ResultEvent` should store status progression (`queued`, `processing`, `processed`, `failed`, `duplicate`).

---

## Suggested Wire Examples

### POST `/api/v1/execute` Request
```json
{
	"command": "create_user",
	"version": "1",
	"payload": {
		"name": "Sahil",
		"email": "sahil@example.com"
	},
	"log": {
		"level": "INFO",
		"message": "User registration triggered"
	},
	"metadata": {
		"idempotency_key": "client-generated-key-123",
		"source": "user-service"
	}
}
```

### POST `/api/v1/execute` Response
```json
{
	"event_id": "b06724ee-8d4b-48c1-b9e1-a447c4bf5ac2",
	"status": "accepted"
}
```

### GET `/api/status/:eventID` Response
```json
{
	"event_id": "b06724ee-8d4b-48c1-b9e1-a447c4bf5ac2",
	"status": "processed",
	"updated_at": "2026-02-21T12:31:10Z"
}
```

---

## Processing Flow
1. Client calls `POST /api/v1/execute`.
2. API validates payload and generates `event_id`.
3. API resolves `idempotency_key` (client key or fallback to `event_id`).
4. API emits command/log events to Kafka.
5. DB Worker processes command and updates idempotency/result record.
6. Worker emits `ResultEvent` and/or persists to internal status table.
7. Client polls `GET /api/status/:eventID` for completion.

---

## Status Storage Decision
- Use a **hybrid model**:
	- Publish terminal/non-terminal updates to the `result` topic.
	- Maintain Kitsune internal status store (DB table) as read model for status API.
- `GET /api/status/:eventID` should read from internal status store for fast and deterministic lookups.
- `result` topic remains the integration/audit stream for other services.

---

## Example Downstream Consumers of `result`
- Notification service (email/SMS/WebSocket updates on processed/failed).
- Retry orchestration service (reacts to retryable failures).
- Analytics/BI pipeline (success rate, latency, error trends).
- Audit/compliance archiver (immutable event history).
- Billing/metering service (charge only for terminal outcomes).
- Webhook dispatcher (pushes final status to external clients).
